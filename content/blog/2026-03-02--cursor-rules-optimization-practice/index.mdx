---
title: Cursor Rules 优化实战：把提示词堆砌改造成可治理的工程体系
slug: cursor-rules-optimization-practice
description: 基于得物技术实践，拆解 Cursor Rules 从冗余冲突到三层治理架构的演进路径，并给出可落地的实施与度量方案。
date: 2026-03-02
lastUpdated: 2026-03-02
tags:
  - Tool
---

:::note[引用说明]
本文基于 阳凯 的文章整理与延展：[Cursor Rules优化实战：构建高效稳定的AI代码生成规范体系｜得物技术](https://mp.weixin.qq.com/s/4hDmCeM6Fl-56hDMoBhLIw)。
:::

如果团队已经在用 Cursor，但仍然频繁遇到“同一个需求生成风格不一致、关键约束漏掉、改一次规则牵全局”的问题，本质上通常不是模型不够强，而是规则系统不可治理。

这篇实践最有价值的点，不是提供一份“更长的规则模板”，而是把规则当作工程系统来设计：分层、分责、可演进、可度量。

## 为什么旧版 Rules 会失效

原文把问题归纳为三类，我认为这三类正好对应了 AI 协作里的三种失稳来源。

1. 信息噪声：规则冗余、描述模糊（例如“保证高性能”）
2. 决策冲突：角色定义互斥、优先级缺失
3. 维护失控：文件职责边界不清、跨文件联动修改

这三件事叠加后，会直接出现两个后果：

- 上下文预算被低价值文本占满，真正关键约束被稀释
- 同一任务在多轮生成中路径漂移，导致结果不可复现

结论很明确：继续往单文件里补充“经验句子”只会加剧问题，需要结构化重构。

## 核心方案：三层架构 + 统一规则语法

推荐把 `.cursor/rules` 设计成三层。

1. `basic/`：全局底线，任何任务都必须加载
2. `modules/`：按技术分层拆分，按需加载
3. `workflow/`：按业务场景编排，约束端到端步骤

相比“按人来组织文档”（架构师规则、开发者规则），三层方案的优势在于调用路径天然稳定：

- `basic` 负责兜底一致性
- `modules` 负责局部专业约束
- `workflow` 负责场景化执行顺序

为了让 AI 真正可执行，规则本身还要统一语法，而不是自然语言随手写。原文中的模板方向是正确的：

```md
# 规则名称

## 基础规范
- 明确范围、输入输出、依赖约束

## 强制行为
- 必须执行的检查项

## 禁止行为
- 明确不可接受的实现

## 示例代码
- 最小可复用示例
```

关键点不在“格式好看”，而在它能把抽象原则转成可判定的动作。

## 工程落地：每层应该写到什么粒度

### 基础层（basic）：只放“跨场景不变约束”

例如目录结构、类型严格策略、命名规范、安全底线、代码复杂度上限、Lint 规范。原文将基础层拆成多个单责文件（如 `code-quality.mdc`、`ts.mdc`、`lint.mdc`），这是正确做法。

判断是否应放在基础层的标准：**任意任务都要遵守，且不依赖具体业务上下文**。

### 模块层（modules）：映射真实代码架构

可以按 `components`、`pages`、`hooks`、`service`、`utils`、`route` 拆分。这样模型在处理某类文件时，只加载对应规则，减少无关上下文干扰。

原文给的 `service` 规范有两个值得保留的实践：

- 统一 API 命名和返回泛型封装
- 把“获取接口详情”前置为强制动作

这类规则的价值是把“团队隐性习惯”转成“模型显式步骤”。

### 流程层（workflow）：固定高频场景的执行顺序

例如 CRUD 页面、埋点接入、日志监控接入。流程层不是再讲一遍规范，而是把任务拆为明确阶段（提取需求、建目录、建类型、建服务、建页面、校验）。

它解决的是“模型知道规范，但执行顺序仍然混乱”的问题。

## 推荐实施路径：先试点，再标准化

我建议直接按三阶段推进，避免一次性大改。

1. 试点阶段：选择 1-2 个高频页面类型验证收益
2. 优化阶段：收集失败样本，回写规则并补示例
3. 标准化阶段：形成团队模板与评审机制

### 用什么指标验证是否真的变好

至少跟踪三类指标：

- 一致性：同类需求多次生成的结构差异率
- 可维护性：单次规则变更影响文件数
- 返工率：生成后人工修改的行数占比

如果没有这些指标，规则优化很容易退化成“主观感觉更顺手”。

## 关键 trade-off：约束密度与模型弹性

规则不是越多越好，而是越可执行越好。

- 约束过密：上下文膨胀，模型探索空间被过度压缩
- 约束过松：输出波动大，人工兜底成本上升

推荐策略是：

- 基础层从严，保证底线
- 模块层和流程层按场景精确加载
- 用最小可运行示例替代空泛口号

这比“全量规则永远注入”更稳定，也更节省 token。

## 总结

这次 Cursor Rules 优化实践的真正启发是：把规则当成软件资产来管理，而不是当成一次性提示词。

当规则具备清晰分层、单一职责、可执行语法和度量闭环后，AI 才能从“偶尔写得好”进入“持续可复现地写得好”。
